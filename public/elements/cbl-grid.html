<link rel="import" href="../../bower_components/neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../../bower_components/neon-animation/animations/cascaded-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-in-animation.html">

<dom-module id="cbl-grid">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host ::content > * {
        position: absolute;
      }
    </style>
    <content></content>
  </template>
  <script>
    Polymer({
      is: 'cbl-grid',

      behaviors: [Polymer.NeonAnimationRunnerBehavior],

      properties: {
        animationConfig: {
          type: Object,
          value: function() {
            return {
              'entry': [{
                name: 'cascaded-animation',
                animation: 'transform-animation',
                transformFrom: 'translateY(100%)',
                transformTo: 'none'
              }]
            }
          }
        }
      },

      attached: function() {
        this.arrange();

        this.play();

        window.addEventListener('resize', () => {
          this.arrange();
        });
      },

      play: function() {
        this.async(function() {
          var nodeList = Polymer.dom(this).node.children;
          this.animationConfig['entry'][0].nodes = Array.prototype.slice.call(nodeList);
          this.playAnimation('entry');
        });
      },

      arrange: function() {
        Polymer.dom.flush();

        let container = Polymer.dom(this).node;
        let items = container.children;

        let margin = (name, item) => {
          let style = window.getComputedStyle(item);
          return parseFloat(style['margin' + name]) || 0;
        };

        let sort = list => {
          list = list.sort((a, b) => {
            return bottom(a) === bottom(b)? x(b) - x(a) : bottom(b) - bottom(a);
          });
        };

        let px = n => n + 'px';
        let y = item => parseFloat(item.style.top);
        let x = item => parseFloat(item.style.left);
        let width = item => item.clientWidth;
        let height = item => item.clientHeight;
        let bottom = item => y(item) + height(item) + margin('Bottom', item);
        let right = item => x(item) + width(item) + margin('Right', item);

        let boundary = [];

        // First item
        if (items.length) {
          items[0].style.top = 0;
          items[0].style.left = 0;
          boundary.push(items[0]);
        }

        // First line
        for (var i = 1; i < items.length; i++) {
          let prev = items[i - 1];
          let item = items[i];
          let hasSpace = right(prev) + width(item) <= width(container);

          if (!hasSpace) break;

          item.style.top = prev.style.top;
          item.style.left = px(right(prev) + margin('Left', item));
          boundary.push(item);
        }

        // Place following elements at the bottom of the smallest column.
        for (; i < items.length; i++) {
          sort(boundary);
          let item = items[i];
          let minItem = boundary.pop();

          item.style.top = px(bottom(minItem) + margin('Top', item));
          item.style.left = px(x(minItem));
          boundary.push(item);
        };

        sort(boundary);

        var maxItem = boundary[0];
        container.style.height = px(bottom(maxItem) + margin('Bottom', maxItem));
      }
    });
  </script>
</dom-module>